
"""
Contains class definitions for filtering algorithms.
Those can be leveraged to deal with noise, e.g.\ by smoothing neighboring data points.

\author Bertram Richter
\date 2022
"""

from abc import abstractmethod
import copy

import numpy as np

from fosanalysis import utils
from . import base

class Filter(base.DataCleaner):
	"""
	Abstract base class for filter classes.
	These filters will modify the values, but not the shape of the arrays.
	
	If both smoothing and cropping are to be applied: smooth first, crop second.
	"""
	def __init__(self,
			*args, **kwargs):
		"""
		Constructs a Filter object.
		As this is an abstract class, it may not be instantiated directly itself.
		\param *args Additional positional arguments, will be passed to the superconstructor.
		\param **kwargs Additional keyword arguments, will be passed to the superconstructor.
		"""
		super().__init__(*args, **kwargs)

class Limit(Filter):
	"""
	A filter to limit the entries.
	The result \f$y\f$ will only contain all entries for which \f$y_i \in [x_{\mathrm{min}},\: x_{\mathrm{max}}]\f$ holds.
	Values, that exceed the limits, will be truncated at the according limit using the equation
	\f[y_i = \min\left(\max\left(x_i,\: x_{\mathrm{min}}\right),\: x_{\mathrm{max}}\right)\f].
	"""
	def __init__(self,
			minimum: float = None,
			maximum: float = None,
			*args, **kwargs):
		"""
		Constructs a Limit filter object.
		\param minimum \copybrief minimum For more, see \ref minimum.
		\param maximum \copybrief maximum For more, see \ref maximum.
		\param *args Additional positional arguments, will be passed to the superconstructor.
		\param **kwargs Additional keyword arguments, will be passed to the superconstructor.
		"""
		super().__init__(*args, **kwargs)
		## Minimal value, which will be included in the result.
		## All entries with values greater than that will be excluded.
		self.minimum = minimum
		## Maximal value, which will be included in the result.
		## All entries with values less than that will be excluded.
		self.maximum = maximum
	def run(self,
			x: np.array,
			y: np.array,
			z: np.array,
			minimum: float = None,
			maximum: float = None,
			make_copy: bool = True,
			*args, **kwargs) -> np.array:
		"""
		Limit the entries in the given list to the specified range.
		Returns a list, which conforms to \f$\mathrm{minimum} \leq x \leq \mathrm{maximum} \forall x \in X\f$.
		Entries, which exceed the given range are cropped to it.
		\param x Array of measuring point positions in accordance to `strain`.
		\param y Array of strain data in accordance to `x`.
			These will be limited to `minimum` and `maximum`.
		\param minimum Minimum value, for the entries. Defaults to `None`, no limit is applied.
		\param maximum Maximum value, for the entries. Defaults to `None`, no limit is applied.
		\param *args Additional positional arguments to customize the behaviour.
		\param **kwargs Additional keyword arguments to customize the behaviour.
		"""
		return super().run(x, y, z,
				timespace="2D",
				make_copy=make_copy,
				minimum=minimum,
				maximum=maximum,
				*args, **kwargs)
	def _run_1d(self, 
			x: np.array, 
			z: np.array,
			*args, **kwargs) -> tuple:
		return x, self._limit(z, *args, **kwargs)
	def _run_2d(self, 
			x: np.array, 
			y: np.array,
			z: np.array,
			*args, **kwargs) -> tuple:
		return x, y, self._limit(z, *args, **kwargs)
	def _limit(self,
			z: np.array,
			minimum: float = None,
			maximum: float = None,
			*args, **kwargs) -> np.array:
		"""
		Limit the values of the array.
		\param z Array with data to be limited.
		\param minimum Minimum value, for the entries. Defaults to `None`, no limit is applied.
		\param maximum Maximum value, for the entries. Defaults to `None`, no limit is applied.
		"""
		minimum = minimum if minimum is not None else self.minimum
		maximum = maximum if maximum is not None else self.maximum
		if minimum is not None:
			z = np.minimum(z, minimum)
		if maximum is not None:
			z = np.maximum(z, maximum)
		return z

class SlidingFilter(Filter):
	"""
	Abstract base class for filter classes, based on sliding windows.
	The sliding windows are generated by \ref utils.misc.sliding_window().
	To each of those sliwind windows, \ref _operation() is applied.
	The result is written to the central pixel of the window.
	Due to boundary effects, it is recommended to smooth first and crop
	second, if both smoothing and cropping are to be applied.
	"""
	def __init__(self,
			radius: int = 0,
			*args, **kwargs):
		"""
		Constructs a \ref SlidingFilter object.
		As this is an abstract class, it may not be instantiated directly itself.
		\param radius \copybrief radius For more, see \ref radius.
		\param *args Additional positional arguments, will be passed to the superconstructor.
		\param **kwargs Additional keyword arguments, will be passed to the superconstructor.
		"""
		super().__init__(*args, **kwargs)
		## Smoothing radius for the data, number of entries of data to each side to be taken into account.
		## Inradius of the window, sets the window's widths.
		## Along an axis, the window has a width of \f$(2r+1)\f$.
		## It is expected to be an `int` or `iterable`. 
		## If `radius` is an integer, it is used for all axes.
		## The window will contain (up to) \f$(2r+1)^2\f$ entries.
		## To set different widths for axes, use an `iterable`, such as a `tuple`.
		## This `tuple`'s length has to match the dimension of `data_array`.
		self.radius = radius
	def run(self,
			x: np.array,
			y: np.array,
			z: np.array,
			timespace: str = None,
			make_copy: bool = True,
			radius: int = None,
			*args, **kwargs) -> np.array:
		"""
		\copydetails SlidingFilter
		\param x Array of measuring point positions in accordance to `strain`.
		\param y Array of strain data in accordance to `x`.
		\param radius \copybrief radius Defaults to \ref radius. For more, see \ref radius.
		\param margins \copybrief margins Defaults to \ref margins. For more, see \ref margins.
		\param *args Additional positional arguments, to customize the behaviour.
		\param **kwargs Additional keyword arguments to customize the behaviour.
		"""
		return super().run(x, y, z,
				timespace=timespace,
				make_copy=make_copy,
				radius=radius,
				*args, **kwargs)
	def _run_1d(self,
			x: np.array, 
			z: np.array,
			*args, **kwargs) -> tuple:
		return x, self._slide(z, *args, **kwargs)
	def _run_2d(self, 
			x: np.array, 
			y: np.array,
			z: np.array,
			*args, **kwargs) -> tuple:
		return x, y, self._slide(z, *args, **kwargs)
	def _slide(self,
			z: np.array,
			radius = None,
			*args, **kwargs) -> np.array:
		"""
		"""
		radius = radius if radius is not None else self.radius
		if radius == 0:
			return z
		smooth_data = np.zeros_like(z)
		# Smooth the middle
		for pixel, window in utils.misc.sliding_window(z, radius):
			smooth_data[pixel] = self._operation(window)
		return smooth_data
	@abstractmethod
	def _operation(self, segment: np.array) -> float:
		"""
		Defines the operation, which is applied to each element in the 
		\f[
			x_{i} \gets \mathrm{op}(x_{j,\:\ldots,\:k}) \text{ with } j = i -r \text{ and } k = i + r
		\f]
		"""
		raise NotImplementedError()

class SlidingMean(SlidingFilter):
	"""
	A filter, that smoothes the record using the mean over \f$2r + 1\f$ entries for each entry.
	\copydetails SlidingFilter
	"""
	def _operation(self, sliding_window: np.array) -> float:
		"""
		Each element in the array to be filtered is assigned the arithmetical average of the sliding window:
		\f[
			x_{i} \gets \frac{\sum{x_{j,\:\ldots,\:k}}}{2r + 1}
		\f]
		"""
		return np.nanmean(sliding_window)

class SlidingMedian(SlidingFilter):
	"""
	A filter, that smoothes the record using the median over \f$2r + 1\f$ entries for each entry.
	\copydetails SlidingFilter
	"""
	def _operation(self, sliding_window: np.array) -> float:
		"""
		Each element in the array to be filtered is assigned the median of the sliding window:
		\f[
			x_{i} \gets
			\begin{cases}
				x_{m+1} & \text{ for odd } n = 2 m +1 \\
				\frac{x_{m} + x_{m+1}}{2} & \text{ for even } n = 2 m
			\end{cases}
			\text{ with } m = 2r + 1
		\f]
		"""
		return np.nanmedian(sliding_window)
